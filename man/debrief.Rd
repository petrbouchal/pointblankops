% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/debrief.R
\name{debrief}
\alias{debrief}
\title{Debrief operative and extract failure intelligence}
\usage{
debrief(
  operative,
  row_id_col,
  parquet_path = NULL,
  con = NULL,
  output_tbl = NULL,
  chunk_size = 1000
)
}
\arguments{
\item{operative}{A pointblank agent or operative object with validation steps}

\item{row_id_col}{Character vector of column names to use as row identifiers.
These columns will be included in the output to identify failing rows.}

\item{parquet_path}{Optional path to save failures as a parquet file. If provided,
failures will be written to this file instead of returned as a tibble.
Requires the 'arrow' package to be installed.}

\item{con}{Optional database connection to save failures. If provided, failures
will be inserted into a database table. Requires the 'DBI' package to be installed.}

\item{output_tbl}{Optional table name for database output. If not provided and
\code{con} is specified, the table name will be inferred as \verb{\{source_table\}_failures}.}

\item{chunk_size}{Number of rows to process at once for memory efficiency.
Default is 1000.}
}
\value{
If no output path is specified, returns a tibble containing failure
records with ID columns, test metadata, and failure details. If \code{parquet_path}
or \code{con} is provided, returns \code{NULL} invisibly after writing the failures.
}
\description{
Extracts failure information from an operative (or agent) that has been
configured with validation steps. This is a memory-efficient alternative to
full interrogation that focuses only on identifying and reporting validation
failures.
}
\examples{
\dontrun{
# Basic usage - return failures as tibble
operative <- create_operative(mtcars) |>
  col_vals_not_null(columns = vars(mpg)) |>
  col_vals_between(columns = vars(cyl), left = 4, right = 8)

failures <- debrief(operative, row_id_col = c("gear", "carb"))

# Save to parquet file (requires arrow package)
# install.packages("arrow")
debrief(operative, row_id_col = "gear", parquet_path = "failures.parquet")

# Save to database (requires DBI package)
# install.packages("DBI")
con <- DBI::dbConnect(duckdb::duckdb(), ":memory:")
debrief(operative, row_id_col = "gear", con = con, output_tbl = "car_failures")
}

}
